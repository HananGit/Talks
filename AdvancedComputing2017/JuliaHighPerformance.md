# Julia for Scientific Computing
## Josh Day
###### https://github.com/joshday 
###### jtday2@ncsu.edu

---
# To run the examples
```julia
pkgs = [
    "Distributions", 
    "Plots", 
    "GR", 
    "RCall",
    "BenchmarkTools",
    "Query",
    "DataTables",
    "JuMP"
]

for pkg in pkgs
    Pkg.add(pkg)
end
```

---
# Overview
- What is Julia?
- Design, Type System, and Multiple Dispatch
- Julia Packages
- Macros

---
# Before We Get To Julia
## Sapir-Worf Hypothesis

---
# Before We Get To Julia
## Sapir-Worf Hypothesis
- Your language determines/influences how you think


---
# What is Julia?
> Julia is a high-level, high-performance dynamic programming language for technical computing, with syntax that is familiar to users of other technical computing environments.
- http://julialang.org

---
# Why Julia?
#### Julia solves the "Two-Language Problem"
- **Prototype** code goes into high-level language like R/Python
- **Production** code goes into low-level language like C/C++

---
# Why Julia?
#### Write high-level code that resembles mathematical formulas
- Yet produces fast, low-level machine code
- Traditionally, this has only been generated by static languages

---
# R is Great, but...
#### Not meant/designed for high performance
- http://adv-r.had.co.nz/Performance.html
#### Deficiencies in core language
- Some fixed with packages (`devtools`, `roxygen2`, `Matrix`)
- Some harder to fix (R uses old version of BLAS)
- Some impossible to fix (clunky syntax, poor design choices)

---
# R is Great, but...
#### Only 6 active developers left (out of 20 R-Core members)
- JuliaLang organization has 74 members, with 567 total contributors (as of 3/3/17)
#### Doug Bates (`lme4`, `Matrix`) quote:
> As some of you may know, I have had a (rather late) mid-life crisis and run off with another language called Julia
- Doug Bates' work in Julia is an example of how Julia gets to learn from the mistakes of other languages
- https://github.com/dmbates/MixedModels.jl

---
![inline](features.png)


---
# Benchmarks
![inline](benchmarks.png)

---
# More than just "Fast R/Python/Matlab"
- Julia is fast because of features which work well together
- You can't just take the magic dust that makes Julia fast and apply it to your favorite language

---
# Julia Language Design
- Type system and type inference
- Multiple dispatch
- Just-in-time (JIT) compilation
- Metaprogramming (macros)

---
# Julia's Growth (Number of Packages)
![](http://pkg.julialang.org/img/allver.svg)

---
# Julia's Growth (Stars on GitHub)
![](http://pkg.julialang.org/img/stars.svg)


---
# Julia Basics
## Everything has a type
```julia
1    # Int64

1.0  # Float64

[1.0, 2.0]  # Vector{Float64}
```

---
# Julia Basics
## Unicode Characters
- Julia's main focus is numerical computing, so creators wanted code to look similar to mathematical formulas:
  $$\hat\beta = (X^TX)^{-1}X^Ty$$
```julia
β̂ = inv(x'x)x'y  # Implicit multiplication

β̂ = inv(x' * x) * x' * y  
```
- Compare this to R:
```r
betahat = solve(t(x) %*% x) %*% t(x) %*% y
```


---
# Julia Basics
## Functions
```julia
f(x) = x ^ 2

# Code blocks require an `end`
function f(x)
    x ^ 2
end
```

---
# Julia Basics
## Mutating functions
- Arguments are passed by reference
- Functions can *mutate* the arguments
- By convention, functions ending in `!` mutate the arguments
```julia
function make_first_zero!(v::Vector{Float64})
    v[1] = 0.0
    v
end
```

---
# Julia Basics
## JIT
- live example with `@code_llvm` macro

```julia
f(x) = x ^ 2

@code_llvm f(1)

@code_llvm f(1.0)
```

---
# Julia Basics
## For loops
Input:
```julia
for i in 1:3
    println(i)
end
```
Output:
```
1
2
3
```

---
# Type System
- When thinking about types, think about sets
- An **abstract** type defines a set of other types
- One abstract type in Julia is `Number`

---
# `Number`
![](tree.png)

---
# `Number`
- What should a `Number` be able to do?
  `+`, `-`, `*`, etc. 
```julia
methods(*)
```
```julia
# 178 methods for generic function "*":
*(x::Bool, z::Complex{Bool}) in Base at complex.jl:225
*(x::Bool, y::Bool) in Base at bool.jl:91
*(x::Bool, y::T) where T<:Unsigned in Base at bool.jl:104
*(x::Bool, z::Complex) in Base at complex.jl:232
*(x::Bool, y::Irrational) in Base at irrationals.jl:105
*(x::Bool, y::T) where T<:Number in Base at bool.jl:101
*(a::Float16, b::Float16) in Base at float.jl:368
*(x::Float32, y::Float32) in Base at float.jl:374
*(x::Float64, y::Float64) in Base at float.jl:375
...
```

---
# Type Annotations
- Consider these three function definitions:
```julia
f(x) = x + x  # too broad?


g(x::Float64) = x + x  # too specific?


h(x::Number) = x + x  # just right
```

---
# Type Annotations
Mainly useful for error handling
- Compare this:
```julia
h(x::Number) = x + x
```
- to this:
```julia
function h(x)
    if isa(x, Number)
        return x + x
    else
        throw(ArgumentError("x should be a number"))
    end
end
```


---
# Multiple Dispatch
- The idea of calling different code depending on the types of the arguments is called **multiple dispatch**.

- Consider the Distributions package, where every distribution has its own type.
```julia
using Distributions

mean(Normal(0, 1)) == 0.0

mean(Gamma(10, 6)) == 60.0
```




---
# Quantile Example
- Suppose I want to find quantiles using Newton's method:
$$\theta_{t+1} = \theta_t - \frac{F(\theta_t) - q}{F'(\theta_t)}$$
  where $F$ is the CDF of a distribution
- In R, I would need a different function for every distribution!
- In Julia, we can do this in one function

---
# The Power of Julia: Abstraction
- Define functions for the "highest" type you can
- A `ContinuousUnivariateDistribution` has methods `mean`, `cdf`, `pdf`
```julia
using Distributions

function myquantile(d::UnivariateDistribution, q::Number)
    θ = mean(d)
    tol = Inf
    while tol > 1e-5
        θold = θ
        θ = θ - (cdf(d, θ) - q) / pdf(d, θ)
        tol = abs(θold - θ)
    end
    θ
end
```

---
Input:
```julia
for d in [Normal(), TDist(4)]
    println("For $d")
    println("  > myquantile: $(myquantile(d, .4))")
    println("  > quantile:   $(quantile(d, .4))\n")
end
```
Output:
```julia
For Distributions.Normal{Float64}(μ=0.0, σ=1.0)
  > myquantile: -0.2533471031356957
  > quantile:   -0.2533471031357997

For Distributions.TDist{Float64}(ν=4.0)
  > myquantile: -0.27072229470638115
  > quantile:   -0.27072229470759746
```

---
# Defining types
- Your own types are just as performant as Julia's built-ins.
- Most of Julia is written in Julia
```julia
# Can change `a` after creating a new instance
type MyType
    a::Int64
end

# Can NOT change `a` after creation
immutable MyOtherType{T <: Number}
   a::T
end
```

---
# Defining methods
Input:
```julia
f(o::MyType) = o.a + o.a

o = MyType(4)
f(o)
```
Output:
```
8
```

---
# Adding methods for existing functions
```julia
Base.:+(o1::MyType, o2::MyType) = MyType(o1.a + o2.a)

MyType(1) + MyType(8)
```

---
# Julia's Package System
**Based on git**
- For registered packages:
```julia
Pkg.add("OnlineStats")
```
- For unregistered packages:
```julia
Pkg.clone("https://github.com/joshday/SparseRegression.jl")
```


---
# Plotting and Graphics
#### Julia does not have a built-in plotting package

- [Plots](https://github.com/JuliaPlots/Plots.jl)
  - Defines a plotting API that can use several "backends"
- [Gadfly](https://github.com/GiovineItalia/Gadfly.jl)
  - Grammar of graphics for Julia
- Others: GR, PyPlot, UnicodePlots, GLPlot, Winston, ...

---
# Plots with PyPlot

```julia
using Plots
pyplot()  # use PyPlot backend
plot(randn(50, 2))
```

![](pyplot2.png)

---
# Plots with GR
```julia
gr()  # use GR backend
plot(randn(50, 2))
```
![](gr.png)

---
# Easy Animations
```julia
anim = @animate for i in 1:20
    plot(sin, 0, i, xlim = (0,20), ylim = (-1, 1))
end
gif(anim, "/Users/joshday/Desktop/my_animation.gif")
```
```
INFO: Saved animation to /Users/joshday/Desktop/my_animation.gif
```

---
![](tmp.gif)

---
# `push!` values to a series
- Input:
```julia
x = randn()

p = plot([x])

for i in 1:100
    x += randn()
    push!(p, x)
end
```
---
- Ouput: 
![inline](push.png)


---
# Calling R from Julia
- Side note: REPL modes 
  - `;` (shell mode)
  - `?` (help mode)
- RCall adds
  - `$` (R mode) 
 
```julia
using RCall
R"rnorm(5)"
```

---
# Calling Python from Julia
Input:
```julia
using PyCall
@pyimport math

math.pi
```
Output:
```
3.141592653589793
```

---
# Statistics, Working with Data, Machine Learning, etc.

- StatsBase, GLM, DataFrames, Query, MixedModels, Distributions, KernelDensity, LossFunctions, ...

---
# StatsBase

Much of the functionality built into R

```julia
using StatsBase

sample(1:5, 5, replace = false)
```

---
# DataFrames and DataTables
- Both for working with tabular data
- DataTables is a fork of DataFrames
  - Behind-the-scenes containers are different 
    - `DataArray` vs. `NullableArray`

---
# DataTables
Input:
```julia
iris = readtable(joinpath(Pkg.dir("DataTables"), 
    "test/data/iris.csv"))
head(iris)
```
Ouput:
```
6×5 DataTables.DataTable
│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species │
├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────┤
│ 1   │ 5.1         │ 3.5        │ 1.4         │ 0.2        │ setosa  │
│ 2   │ 4.9         │ 3.0        │ 1.4         │ 0.2        │ setosa  │
│ 3   │ 4.7         │ 3.2        │ 1.3         │ 0.2        │ setosa  │
│ 4   │ 4.6         │ 3.1        │ 1.5         │ 0.2        │ setosa  │
│ 5   │ 5.0         │ 3.6        │ 1.4         │ 0.2        │ setosa  │
│ 6   │ 5.4         │ 3.9        │ 1.7         │ 0.4        │ setosa  │
```

---
# Query (query almost any data source)
```julia
using Query

x = @from i in iris begin
    @where i.Species == "setosa" && i.PetalLength > 1.7  
    @select i
    @collect DataTable
end
```

```
2×5 DataTables.DataTable
│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species │
├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────┤
│ 1   │ 4.8         │ 3.4        │ 1.9         │ 0.2        │ setosa  │
│ 2   │ 5.1         │ 3.8        │ 1.9         │ 0.4        │ setosa  │
```

---
# JuMP
```julia
using JuMP, Ipopt

n = 1000
data = randn(n)

m = Model(solver = IpoptSolver())
@variable(m, μ, start = 0.0)
@variable(m, σ >= 0.0, start = 1.0)
@NLobjective(m, Max, (n/2)*log(1/(2π*σ^2))-sum((data[i]-μ)^2 for i=1:n)/(2σ^2))
solve(m)

println("μ = ", getvalue(μ))
println("σ = ", getvalue(σ))
```


---
# Macros

---
# Macros
- Macros are functions of expressions
- They change an expression before it is run
```julia
x = randn(1000);

@time sum(x)  # JIT at work
#   0.031018 seconds (12.86 k allocations: 602.013 KB)
# -34.195601715147035

@time sum(x)
#   0.000003 seconds (5 allocations: 176 bytes)
# -34.195601715147035
```

---
# Macros (turn off bounds checking)
```julia
x = rand(1000)

for i in eachindex(x)
    @inbounds x[i] *= 5.0
end
```

--- 
# Macros (benchmarking)
```julia
using BenchmarkTools
@benchmark sum(x)
```
```
BenchmarkTools.Trial:
  memory estimate:  16 bytes
  allocs estimate:  1
  --------------
  minimum time:     223.038 ns (0.00% GC)
  median time:      237.132 ns (0.00% GC)
  mean time:        257.436 ns (0.58% GC)
  maximum time:     8.601 μs (95.37% GC)
  --------------
  samples:          10000
  evals/sample:     478
  time tolerance:   5.00%
  memory tolerance: 1.00%
```

---
# Macros (Views)
```julia
x = randn(100,100)

x[:, 1]        # creates a copy

@view x[:, 1]  # creates a "view"
```

---
# Macros (Other)
```julia
@which sum(x)  # find the method being called

@edit sum(x)   # open file where the method is
```


---
# Recommendations

---
# My Thoughts
- **Julia is ideal for developing projects from scratch/with few dependencies**
- The package ecosystem is growing fast but is still lacking much of the functionality you can find in R
- However, there are many interesting things in Julia that R doesn't have:
  - Plots, Convex, JuMP, OnlineStats, Distributions, LossFunctions, ...


---
# Thank You